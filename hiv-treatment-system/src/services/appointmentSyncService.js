// Service for syncing appointment data across different user roles
class AppointmentSyncService {
  constructor() {
    // In a real application, this would use API endpoints
    this.apiEndpoints = {
      patient: '/api/patient/appointments',
      staff: '/api/staff/appointments',
      doctor: '/api/doctor/appointments',
      notifications: '/api/notifications'
    };
  }

  /**
   * Sync completed appointment data across all systems
   * @param {Object} appointmentData - Completed appointment data
   */
  async syncCompletedAppointment(appointmentData) {
    try {
      console.log('ðŸ”„ Starting appointment sync across systems...');
      
      // 1. Update patient's medical records
      await this.updatePatientRecords(appointmentData);
      
      // 2. Update staff appointment management
      await this.updateStaffSystem(appointmentData);
      
      // 3. Create follow-up appointment if required
      if (appointmentData.followUpRequired) {
        await this.createFollowUpAppointment(appointmentData);
      }
      
      // 4. Send notifications
      await this.sendNotifications(appointmentData);
      
      // 5. Update medication records
      if (appointmentData.medications && appointmentData.medications.length > 0) {
        await this.updateMedicationRecords(appointmentData);
      }
      
      console.log('âœ… Appointment sync completed successfully');
      return { success: true, message: 'Äá»“ng bá»™ dá»¯ liá»‡u thÃ nh cÃ´ng' };
      
    } catch (error) {
      console.error('âŒ Appointment sync failed:', error);
      return { success: false, message: 'Lá»—i Ä‘á»“ng bá»™ dá»¯ liá»‡u', error };
    }
  }

  /**
   * Update patient's medical records and appointment history
   */
  async updatePatientRecords(appointmentData) {
    const patientUpdate = {
      patientId: appointmentData.patientId,
      appointmentHistory: {
        id: appointmentData.id,
        date: appointmentData.date,
        time: appointmentData.time,
        doctorName: 'BS. Nguyá»…n VÄƒn Minh',
        diagnosis: appointmentData.diagnosis,
        medications: appointmentData.medications,
        treatments: appointmentData.treatments,
        notes: appointmentData.notes,
        status: 'completed',
        completedAt: appointmentData.completedAt
      },
      lastVisit: appointmentData.date,
      nextAppointment: appointmentData.followUpRequired ? appointmentData.nextAppointmentDate : null
    };

    // Simulate API call
    console.log('ðŸ“‹ Updating patient records:', patientUpdate);
    
    // In real implementation:
    // return await fetch(this.apiEndpoints.patient, {
    //   method: 'POST',
    //   headers: { 'Content-Type': 'application/json' },
    //   body: JSON.stringify(patientUpdate)
    // });
    
    return Promise.resolve(patientUpdate);
  }

  /**
   * Update staff appointment management system
   */
  async updateStaffSystem(appointmentData) {
    const staffUpdate = {
      appointmentId: appointmentData.id,
      patientId: appointmentData.patientId,
      patientName: appointmentData.patientName,
      status: 'completed',
      completedBy: 'BS. Nguyá»…n VÄƒn Minh',
      completedAt: appointmentData.completedAt,
      diagnosis: appointmentData.diagnosis,
      followUpRequired: appointmentData.followUpRequired,
      nextAppointmentDate: appointmentData.nextAppointmentDate,
      medications: appointmentData.medications,
      treatments: appointmentData.treatments
    };

    console.log('ðŸ‘¥ Updating staff system:', staffUpdate);
    
    // Update staff dashboard statistics
    this.updateStaffStatistics(appointmentData);
    
    return Promise.resolve(staffUpdate);
  }

  /**
   * Create follow-up appointment automatically
   */
  async createFollowUpAppointment(appointmentData) {
    if (!appointmentData.followUpRequired || !appointmentData.nextAppointmentDate) {
      return;
    }

    const followUpAppointment = {
      id: `FU_${appointmentData.id}_${Date.now()}`,
      patientId: appointmentData.patientId,
      patientName: appointmentData.patientName,
      type: 'follow_up',
      date: appointmentData.nextAppointmentDate,
      time: '09:00', // Default time, can be adjusted by staff
      duration: 30,
      status: 'scheduled',
      reason: 'TÃ¡i khÃ¡m theo chá»‰ Ä‘á»‹nh bÃ¡c sÄ©',
      notes: `TÃ¡i khÃ¡m sau cuá»™c háº¹n ngÃ y ${appointmentData.date}. Cháº©n Ä‘oÃ¡n: ${appointmentData.diagnosis}`,
      priority: this.calculateFollowUpPriority(appointmentData),
      isVirtual: false,
      reminderSent: false,
      createdBy: 'system',
      parentAppointmentId: appointmentData.id,
      autoGenerated: true
    };

    console.log('ðŸ“… Creating follow-up appointment:', followUpAppointment);
    
    // This would create the appointment in all systems
    await this.syncNewAppointment(followUpAppointment);
    
    return followUpAppointment;
  }

  /**
   * Calculate priority for follow-up appointment based on diagnosis and treatments
   */
  calculateFollowUpPriority(appointmentData) {
    const diagnosis = appointmentData.diagnosis.toLowerCase();
    const treatments = appointmentData.treatments.join(' ').toLowerCase();
    
    // High priority conditions
    if (diagnosis.includes('aids') || 
        diagnosis.includes('nhiá»…m trÃ¹ng cÆ¡ há»™i') ||
        diagnosis.includes('khÃ¡ng thuá»‘c') ||
        treatments.includes('thay Ä‘á»•i phÃ¡c Ä‘á»“') ||
        treatments.includes('táº¡m ngá»«ng Ä‘iá»u trá»‹')) {
      return 'high';
    }
    
    // Medium priority conditions
    if (diagnosis.includes('cÃ³ triá»‡u chá»©ng') ||
        treatments.includes('Ä‘iá»u chá»‰nh liá»u') ||
        treatments.includes('theo dÃµi tÃ¡c dá»¥ng phá»¥')) {
      return 'medium';
    }
    
    // Default to low priority
    return 'low';
  }

  /**
   * Sync new appointment across all systems
   */
  async syncNewAppointment(appointmentData) {
    // Add to doctor's schedule
    console.log('ðŸ‘¨â€âš•ï¸ Adding to doctor schedule:', appointmentData);
    
    // Add to staff management system
    console.log('ðŸ‘¥ Adding to staff system:', appointmentData);
    
    // Add to patient's upcoming appointments
    console.log('ðŸ¤’ Adding to patient appointments:', appointmentData);
    
    return Promise.resolve(appointmentData);
  }

  /**
   * Send notifications to relevant parties
   */
  async sendNotifications(appointmentData) {
    const notifications = [];

    // Notification to patient
    notifications.push({
      recipientId: appointmentData.patientId,
      recipientType: 'patient',
      type: 'appointment_completed',
      title: 'Káº¿t quáº£ khÃ¡m bá»‡nh',
      message: `Cuá»™c háº¹n ngÃ y ${appointmentData.date} Ä‘Ã£ hoÃ n thÃ nh. Cháº©n Ä‘oÃ¡n: ${appointmentData.diagnosis}`,
      data: {
        appointmentId: appointmentData.id,
        diagnosis: appointmentData.diagnosis,
        medications: appointmentData.medications,
        nextAppointment: appointmentData.nextAppointmentDate
      },
      priority: 'normal',
      createdAt: new Date().toISOString()
    });

    // Notification for follow-up appointment
    if (appointmentData.followUpRequired) {
      notifications.push({
        recipientId: appointmentData.patientId,
        recipientType: 'patient',
        type: 'follow_up_scheduled',
        title: 'Lá»‹ch tÃ¡i khÃ¡m Ä‘Ã£ Ä‘Æ°á»£c Ä‘áº·t',
        message: `Báº¡n cÃ³ lá»‹ch tÃ¡i khÃ¡m vÃ o ngÃ y ${new Date(appointmentData.nextAppointmentDate).toLocaleDateString('vi-VN')}`,
        data: {
          appointmentDate: appointmentData.nextAppointmentDate,
          parentAppointmentId: appointmentData.id
        },
        priority: 'high',
        createdAt: new Date().toISOString()
      });

      // Notification to staff about new follow-up appointment
      notifications.push({
        recipientType: 'staff',
        type: 'new_appointment_created',
        title: 'Lá»‹ch tÃ¡i khÃ¡m má»›i Ä‘Æ°á»£c táº¡o',
        message: `Há»‡ thá»‘ng Ä‘Ã£ tá»± Ä‘á»™ng táº¡o lá»‹ch tÃ¡i khÃ¡m cho bá»‡nh nhÃ¢n ${appointmentData.patientName} vÃ o ngÃ y ${new Date(appointmentData.nextAppointmentDate).toLocaleDateString('vi-VN')}`,
        data: {
          patientId: appointmentData.patientId,
          patientName: appointmentData.patientName,
          appointmentDate: appointmentData.nextAppointmentDate,
          priority: this.calculateFollowUpPriority(appointmentData)
        },
        priority: 'normal',
        createdAt: new Date().toISOString()
      });
    }

    // Send medication reminders if new medications prescribed
    if (appointmentData.medications && appointmentData.medications.length > 0) {
      notifications.push({
        recipientId: appointmentData.patientId,
        recipientType: 'patient',
        type: 'medication_prescribed',
        title: 'ÄÆ¡n thuá»‘c má»›i',
        message: `BÃ¡c sÄ© Ä‘Ã£ kÃª Ä‘Æ¡n thuá»‘c má»›i cho báº¡n. Vui lÃ²ng tuÃ¢n thá»§ Ä‘Ãºng liá»u lÆ°á»£ng vÃ  thá»i gian.`,
        data: {
          medications: appointmentData.medications,
          appointmentId: appointmentData.id
        },
        priority: 'high',
        createdAt: new Date().toISOString()
      });
    }

    console.log('ðŸ”” Sending notifications:', notifications);
    
    // In real implementation, send to notification service
    return Promise.resolve(notifications);
  }

  /**
   * Update medication records for patient
   */
  async updateMedicationRecords(appointmentData) {
    const medicationUpdate = {
      patientId: appointmentData.patientId,
      prescribedBy: 'BS. Nguyá»…n VÄƒn Minh',
      prescribedAt: appointmentData.completedAt,
      appointmentId: appointmentData.id,
      medications: appointmentData.medications.map(med => ({
        ...med,
        status: 'active',
        startDate: new Date().toISOString().split('T')[0],
        prescribedBy: 'BS. Nguyá»…n VÄƒn Minh'
      }))
    };

    console.log('ðŸ’Š Updating medication records:', medicationUpdate);
    
    return Promise.resolve(medicationUpdate);
  }

  /**
   * Update staff dashboard statistics
   */
  updateStaffStatistics(appointmentData) {
    const stats = {
      completedAppointments: 1,
      patientsServed: 1,
      followUpScheduled: appointmentData.followUpRequired ? 1 : 0,
      medicationsPrescribed: appointmentData.medications ? appointmentData.medications.length : 0
    };

    console.log('ðŸ“Š Updating staff statistics:', stats);
    return stats;
  }

  /**
   * Get sync status for an appointment
   */
  async getSyncStatus(appointmentId) {
    // In real implementation, check sync status across all systems
    return {
      appointmentId,
      patientRecords: 'synced',
      staffSystem: 'synced',
      notifications: 'synced',
      followUpCreated: 'synced',
      lastSyncAt: new Date().toISOString()
    };
  }

  /**
   * Retry failed sync operations
   */
  async retrySyncOperation(appointmentId, operation) {
    console.log(`ðŸ”„ Retrying sync operation: ${operation} for appointment: ${appointmentId}`);
    // Implementation for retry logic
    return Promise.resolve({ success: true });
  }
}

// Export singleton instance
export const appointmentSyncService = new AppointmentSyncService();
export default appointmentSyncService; 